// GENERATED BY graphql-code-generator. DO NOT EDIT
/* eslint-disable */

import gql from "graphql-tag";
import * as React from "react";
import * as ReactApollo from "react-apollo";
export type Maybe<T> = T | null;
export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  uuid: any;
  numeric: any;
};

/** columns and relationships of "businesses" */
export type Businesses = {
  __typename?: "businesses";
  id: Scalars["uuid"];
  lat?: Maybe<Scalars["numeric"]>;
  long?: Maybe<Scalars["numeric"]>;
  name: Scalars["String"];
  /** An array relationship */
  reviews: Array<Reviews>;
  /** An aggregated array relationship */
  reviews_aggregate: Reviews_Aggregate;
};

/** columns and relationships of "businesses" */
export type BusinessesReviewsArgs = {
  distinct_on?: Maybe<Array<Reviews_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Reviews_Order_By>>;
  where?: Maybe<Reviews_Bool_Exp>;
};

/** columns and relationships of "businesses" */
export type BusinessesReviews_AggregateArgs = {
  distinct_on?: Maybe<Array<Reviews_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Reviews_Order_By>>;
  where?: Maybe<Reviews_Bool_Exp>;
};

/** aggregated selection of "businesses" */
export type Businesses_Aggregate = {
  __typename?: "businesses_aggregate";
  aggregate?: Maybe<Businesses_Aggregate_Fields>;
  nodes: Array<Businesses>;
};

/** aggregate fields of "businesses" */
export type Businesses_Aggregate_Fields = {
  __typename?: "businesses_aggregate_fields";
  avg?: Maybe<Businesses_Avg_Fields>;
  count?: Maybe<Scalars["Int"]>;
  max?: Maybe<Businesses_Max_Fields>;
  min?: Maybe<Businesses_Min_Fields>;
  stddev?: Maybe<Businesses_Stddev_Fields>;
  stddev_pop?: Maybe<Businesses_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Businesses_Stddev_Samp_Fields>;
  sum?: Maybe<Businesses_Sum_Fields>;
  var_pop?: Maybe<Businesses_Var_Pop_Fields>;
  var_samp?: Maybe<Businesses_Var_Samp_Fields>;
  variance?: Maybe<Businesses_Variance_Fields>;
};

/** aggregate fields of "businesses" */
export type Businesses_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Businesses_Select_Column>>;
  distinct?: Maybe<Scalars["Boolean"]>;
};

/** order by aggregate values of table "businesses" */
export type Businesses_Aggregate_Order_By = {
  avg?: Maybe<Businesses_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Businesses_Max_Order_By>;
  min?: Maybe<Businesses_Min_Order_By>;
  stddev?: Maybe<Businesses_Stddev_Order_By>;
  stddev_pop?: Maybe<Businesses_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Businesses_Stddev_Samp_Order_By>;
  sum?: Maybe<Businesses_Sum_Order_By>;
  var_pop?: Maybe<Businesses_Var_Pop_Order_By>;
  var_samp?: Maybe<Businesses_Var_Samp_Order_By>;
  variance?: Maybe<Businesses_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "businesses" */
export type Businesses_Arr_Rel_Insert_Input = {
  data: Array<Businesses_Insert_Input>;
  on_conflict?: Maybe<Businesses_On_Conflict>;
};

/** aggregate avg on columns */
export type Businesses_Avg_Fields = {
  __typename?: "businesses_avg_fields";
  lat?: Maybe<Scalars["Float"]>;
  long?: Maybe<Scalars["Float"]>;
};

/** order by avg() on columns of table "businesses" */
export type Businesses_Avg_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "businesses". All fields are combined with a logical 'AND'. */
export type Businesses_Bool_Exp = {
  _and?: Maybe<Array<Maybe<Businesses_Bool_Exp>>>;
  _not?: Maybe<Businesses_Bool_Exp>;
  _or?: Maybe<Array<Maybe<Businesses_Bool_Exp>>>;
  id?: Maybe<Uuid_Comparison_Exp>;
  lat?: Maybe<Numeric_Comparison_Exp>;
  long?: Maybe<Numeric_Comparison_Exp>;
  name?: Maybe<Text_Comparison_Exp>;
  reviews?: Maybe<Reviews_Bool_Exp>;
};

/** unique or primary key constraints on table "businesses" */
export enum Businesses_Constraint {
  /** unique or primary key constraint */
  BusinessesPkey = "businesses_pkey"
}

/** input type for inserting data into table "businesses" */
export type Businesses_Insert_Input = {
  id?: Maybe<Scalars["uuid"]>;
  lat?: Maybe<Scalars["numeric"]>;
  long?: Maybe<Scalars["numeric"]>;
  name?: Maybe<Scalars["String"]>;
  reviews?: Maybe<Reviews_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Businesses_Max_Fields = {
  __typename?: "businesses_max_fields";
  lat?: Maybe<Scalars["numeric"]>;
  long?: Maybe<Scalars["numeric"]>;
  name?: Maybe<Scalars["String"]>;
};

/** order by max() on columns of table "businesses" */
export type Businesses_Max_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Businesses_Min_Fields = {
  __typename?: "businesses_min_fields";
  lat?: Maybe<Scalars["numeric"]>;
  long?: Maybe<Scalars["numeric"]>;
  name?: Maybe<Scalars["String"]>;
};

/** order by min() on columns of table "businesses" */
export type Businesses_Min_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
};

/** response of any mutation on the table "businesses" */
export type Businesses_Mutation_Response = {
  __typename?: "businesses_mutation_response";
  /** number of affected rows by the mutation */
  affected_rows: Scalars["Int"];
  /** data of the affected rows by the mutation */
  returning: Array<Businesses>;
};

/** input type for inserting object relation for remote table "businesses" */
export type Businesses_Obj_Rel_Insert_Input = {
  data: Businesses_Insert_Input;
  on_conflict?: Maybe<Businesses_On_Conflict>;
};

/** on conflict condition type for table "businesses" */
export type Businesses_On_Conflict = {
  constraint: Businesses_Constraint;
  update_columns: Array<Businesses_Update_Column>;
};

/** ordering options when selecting data from "businesses" */
export type Businesses_Order_By = {
  id?: Maybe<Order_By>;
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
  name?: Maybe<Order_By>;
  reviews_aggregate?: Maybe<Reviews_Aggregate_Order_By>;
};

/** select columns of table "businesses" */
export enum Businesses_Select_Column {
  /** column name */
  Id = "id",
  /** column name */
  Lat = "lat",
  /** column name */
  Long = "long",
  /** column name */
  Name = "name"
}

/** input type for updating data in table "businesses" */
export type Businesses_Set_Input = {
  id?: Maybe<Scalars["uuid"]>;
  lat?: Maybe<Scalars["numeric"]>;
  long?: Maybe<Scalars["numeric"]>;
  name?: Maybe<Scalars["String"]>;
};

/** aggregate stddev on columns */
export type Businesses_Stddev_Fields = {
  __typename?: "businesses_stddev_fields";
  lat?: Maybe<Scalars["Float"]>;
  long?: Maybe<Scalars["Float"]>;
};

/** order by stddev() on columns of table "businesses" */
export type Businesses_Stddev_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Businesses_Stddev_Pop_Fields = {
  __typename?: "businesses_stddev_pop_fields";
  lat?: Maybe<Scalars["Float"]>;
  long?: Maybe<Scalars["Float"]>;
};

/** order by stddev_pop() on columns of table "businesses" */
export type Businesses_Stddev_Pop_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Businesses_Stddev_Samp_Fields = {
  __typename?: "businesses_stddev_samp_fields";
  lat?: Maybe<Scalars["Float"]>;
  long?: Maybe<Scalars["Float"]>;
};

/** order by stddev_samp() on columns of table "businesses" */
export type Businesses_Stddev_Samp_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Businesses_Sum_Fields = {
  __typename?: "businesses_sum_fields";
  lat?: Maybe<Scalars["numeric"]>;
  long?: Maybe<Scalars["numeric"]>;
};

/** order by sum() on columns of table "businesses" */
export type Businesses_Sum_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** update columns of table "businesses" */
export enum Businesses_Update_Column {
  /** column name */
  Id = "id",
  /** column name */
  Lat = "lat",
  /** column name */
  Long = "long",
  /** column name */
  Name = "name"
}

/** aggregate var_pop on columns */
export type Businesses_Var_Pop_Fields = {
  __typename?: "businesses_var_pop_fields";
  lat?: Maybe<Scalars["Float"]>;
  long?: Maybe<Scalars["Float"]>;
};

/** order by var_pop() on columns of table "businesses" */
export type Businesses_Var_Pop_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Businesses_Var_Samp_Fields = {
  __typename?: "businesses_var_samp_fields";
  lat?: Maybe<Scalars["Float"]>;
  long?: Maybe<Scalars["Float"]>;
};

/** order by var_samp() on columns of table "businesses" */
export type Businesses_Var_Samp_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Businesses_Variance_Fields = {
  __typename?: "businesses_variance_fields";
  lat?: Maybe<Scalars["Float"]>;
  long?: Maybe<Scalars["Float"]>;
};

/** order by variance() on columns of table "businesses" */
export type Businesses_Variance_Order_By = {
  lat?: Maybe<Order_By>;
  long?: Maybe<Order_By>;
};

/** conflict action */
export enum Conflict_Action {
  /** ignore the insert on this row */
  Ignore = "ignore",
  /** update the row with the given values */
  Update = "update"
}

/** expression to compare columns of type integer. All fields are combined with logical 'AND'. */
export type Integer_Comparison_Exp = {
  _eq?: Maybe<Scalars["Int"]>;
  _gt?: Maybe<Scalars["Int"]>;
  _gte?: Maybe<Scalars["Int"]>;
  _in?: Maybe<Array<Scalars["Int"]>>;
  _is_null?: Maybe<Scalars["Boolean"]>;
  _lt?: Maybe<Scalars["Int"]>;
  _lte?: Maybe<Scalars["Int"]>;
  _neq?: Maybe<Scalars["Int"]>;
  _nin?: Maybe<Array<Scalars["Int"]>>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: "mutation_root";
  /** delete data from the table: "businesses" */
  delete_businesses?: Maybe<Businesses_Mutation_Response>;
  /** delete data from the table: "reviews" */
  delete_reviews?: Maybe<Reviews_Mutation_Response>;
  /** insert data into the table: "businesses" */
  insert_businesses?: Maybe<Businesses_Mutation_Response>;
  /** insert data into the table: "reviews" */
  insert_reviews?: Maybe<Reviews_Mutation_Response>;
  /** update data of the table: "businesses" */
  update_businesses?: Maybe<Businesses_Mutation_Response>;
  /** update data of the table: "reviews" */
  update_reviews?: Maybe<Reviews_Mutation_Response>;
};

/** mutation root */
export type Mutation_RootDelete_BusinessesArgs = {
  where: Businesses_Bool_Exp;
};

/** mutation root */
export type Mutation_RootDelete_ReviewsArgs = {
  where: Reviews_Bool_Exp;
};

/** mutation root */
export type Mutation_RootInsert_BusinessesArgs = {
  objects: Array<Businesses_Insert_Input>;
  on_conflict?: Maybe<Businesses_On_Conflict>;
};

/** mutation root */
export type Mutation_RootInsert_ReviewsArgs = {
  objects: Array<Reviews_Insert_Input>;
  on_conflict?: Maybe<Reviews_On_Conflict>;
};

/** mutation root */
export type Mutation_RootUpdate_BusinessesArgs = {
  _set?: Maybe<Businesses_Set_Input>;
  where: Businesses_Bool_Exp;
};

/** mutation root */
export type Mutation_RootUpdate_ReviewsArgs = {
  _inc?: Maybe<Reviews_Inc_Input>;
  _set?: Maybe<Reviews_Set_Input>;
  where: Reviews_Bool_Exp;
};

/** expression to compare columns of type numeric. All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: Maybe<Scalars["numeric"]>;
  _gt?: Maybe<Scalars["numeric"]>;
  _gte?: Maybe<Scalars["numeric"]>;
  _in?: Maybe<Array<Scalars["numeric"]>>;
  _is_null?: Maybe<Scalars["Boolean"]>;
  _lt?: Maybe<Scalars["numeric"]>;
  _lte?: Maybe<Scalars["numeric"]>;
  _neq?: Maybe<Scalars["numeric"]>;
  _nin?: Maybe<Array<Scalars["numeric"]>>;
};

/** column ordering options */
export enum Order_By {
  /** in the ascending order, nulls last */
  Asc = "asc",
  /** in the ascending order, nulls first */
  AscNullsFirst = "asc_nulls_first",
  /** in the ascending order, nulls last */
  AscNullsLast = "asc_nulls_last",
  /** in the descending order, nulls first */
  Desc = "desc",
  /** in the descending order, nulls first */
  DescNullsFirst = "desc_nulls_first",
  /** in the descending order, nulls last */
  DescNullsLast = "desc_nulls_last"
}

/** query root */
export type Query_Root = {
  __typename?: "query_root";
  /** fetch data from the table: "businesses" */
  businesses: Array<Businesses>;
  /** fetch aggregated fields from the table: "businesses" */
  businesses_aggregate: Businesses_Aggregate;
  /** fetch data from the table: "businesses" using primary key columns */
  businesses_by_pk?: Maybe<Businesses>;
  /** fetch data from the table: "reviews" */
  reviews: Array<Reviews>;
  /** fetch aggregated fields from the table: "reviews" */
  reviews_aggregate: Reviews_Aggregate;
  /** fetch data from the table: "reviews" using primary key columns */
  reviews_by_pk?: Maybe<Reviews>;
};

/** query root */
export type Query_RootBusinessesArgs = {
  distinct_on?: Maybe<Array<Businesses_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Businesses_Order_By>>;
  where?: Maybe<Businesses_Bool_Exp>;
};

/** query root */
export type Query_RootBusinesses_AggregateArgs = {
  distinct_on?: Maybe<Array<Businesses_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Businesses_Order_By>>;
  where?: Maybe<Businesses_Bool_Exp>;
};

/** query root */
export type Query_RootBusinesses_By_PkArgs = {
  id: Scalars["uuid"];
};

/** query root */
export type Query_RootReviewsArgs = {
  distinct_on?: Maybe<Array<Reviews_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Reviews_Order_By>>;
  where?: Maybe<Reviews_Bool_Exp>;
};

/** query root */
export type Query_RootReviews_AggregateArgs = {
  distinct_on?: Maybe<Array<Reviews_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Reviews_Order_By>>;
  where?: Maybe<Reviews_Bool_Exp>;
};

/** query root */
export type Query_RootReviews_By_PkArgs = {
  id: Scalars["uuid"];
};

/** columns and relationships of "reviews" */
export type Reviews = {
  __typename?: "reviews";
  /** An object relationship */
  business: Businesses;
  bussiness_id: Scalars["uuid"];
  id: Scalars["uuid"];
  rating: Scalars["Int"];
  text: Scalars["String"];
};

/** aggregated selection of "reviews" */
export type Reviews_Aggregate = {
  __typename?: "reviews_aggregate";
  aggregate?: Maybe<Reviews_Aggregate_Fields>;
  nodes: Array<Reviews>;
};

/** aggregate fields of "reviews" */
export type Reviews_Aggregate_Fields = {
  __typename?: "reviews_aggregate_fields";
  avg?: Maybe<Reviews_Avg_Fields>;
  count?: Maybe<Scalars["Int"]>;
  max?: Maybe<Reviews_Max_Fields>;
  min?: Maybe<Reviews_Min_Fields>;
  stddev?: Maybe<Reviews_Stddev_Fields>;
  stddev_pop?: Maybe<Reviews_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Reviews_Stddev_Samp_Fields>;
  sum?: Maybe<Reviews_Sum_Fields>;
  var_pop?: Maybe<Reviews_Var_Pop_Fields>;
  var_samp?: Maybe<Reviews_Var_Samp_Fields>;
  variance?: Maybe<Reviews_Variance_Fields>;
};

/** aggregate fields of "reviews" */
export type Reviews_Aggregate_FieldsCountArgs = {
  columns?: Maybe<Array<Reviews_Select_Column>>;
  distinct?: Maybe<Scalars["Boolean"]>;
};

/** order by aggregate values of table "reviews" */
export type Reviews_Aggregate_Order_By = {
  avg?: Maybe<Reviews_Avg_Order_By>;
  count?: Maybe<Order_By>;
  max?: Maybe<Reviews_Max_Order_By>;
  min?: Maybe<Reviews_Min_Order_By>;
  stddev?: Maybe<Reviews_Stddev_Order_By>;
  stddev_pop?: Maybe<Reviews_Stddev_Pop_Order_By>;
  stddev_samp?: Maybe<Reviews_Stddev_Samp_Order_By>;
  sum?: Maybe<Reviews_Sum_Order_By>;
  var_pop?: Maybe<Reviews_Var_Pop_Order_By>;
  var_samp?: Maybe<Reviews_Var_Samp_Order_By>;
  variance?: Maybe<Reviews_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "reviews" */
export type Reviews_Arr_Rel_Insert_Input = {
  data: Array<Reviews_Insert_Input>;
  on_conflict?: Maybe<Reviews_On_Conflict>;
};

/** aggregate avg on columns */
export type Reviews_Avg_Fields = {
  __typename?: "reviews_avg_fields";
  rating?: Maybe<Scalars["Float"]>;
};

/** order by avg() on columns of table "reviews" */
export type Reviews_Avg_Order_By = {
  rating?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "reviews". All fields are combined with a logical 'AND'. */
export type Reviews_Bool_Exp = {
  _and?: Maybe<Array<Maybe<Reviews_Bool_Exp>>>;
  _not?: Maybe<Reviews_Bool_Exp>;
  _or?: Maybe<Array<Maybe<Reviews_Bool_Exp>>>;
  business?: Maybe<Businesses_Bool_Exp>;
  bussiness_id?: Maybe<Uuid_Comparison_Exp>;
  id?: Maybe<Uuid_Comparison_Exp>;
  rating?: Maybe<Integer_Comparison_Exp>;
  text?: Maybe<Text_Comparison_Exp>;
};

/** unique or primary key constraints on table "reviews" */
export enum Reviews_Constraint {
  /** unique or primary key constraint */
  ReviewsPkey = "reviews_pkey"
}

/** input type for incrementing integer columne in table "reviews" */
export type Reviews_Inc_Input = {
  rating?: Maybe<Scalars["Int"]>;
};

/** input type for inserting data into table "reviews" */
export type Reviews_Insert_Input = {
  business?: Maybe<Businesses_Obj_Rel_Insert_Input>;
  bussiness_id?: Maybe<Scalars["uuid"]>;
  id?: Maybe<Scalars["uuid"]>;
  rating?: Maybe<Scalars["Int"]>;
  text?: Maybe<Scalars["String"]>;
};

/** aggregate max on columns */
export type Reviews_Max_Fields = {
  __typename?: "reviews_max_fields";
  rating?: Maybe<Scalars["Int"]>;
  text?: Maybe<Scalars["String"]>;
};

/** order by max() on columns of table "reviews" */
export type Reviews_Max_Order_By = {
  rating?: Maybe<Order_By>;
  text?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Reviews_Min_Fields = {
  __typename?: "reviews_min_fields";
  rating?: Maybe<Scalars["Int"]>;
  text?: Maybe<Scalars["String"]>;
};

/** order by min() on columns of table "reviews" */
export type Reviews_Min_Order_By = {
  rating?: Maybe<Order_By>;
  text?: Maybe<Order_By>;
};

/** response of any mutation on the table "reviews" */
export type Reviews_Mutation_Response = {
  __typename?: "reviews_mutation_response";
  /** number of affected rows by the mutation */
  affected_rows: Scalars["Int"];
  /** data of the affected rows by the mutation */
  returning: Array<Reviews>;
};

/** input type for inserting object relation for remote table "reviews" */
export type Reviews_Obj_Rel_Insert_Input = {
  data: Reviews_Insert_Input;
  on_conflict?: Maybe<Reviews_On_Conflict>;
};

/** on conflict condition type for table "reviews" */
export type Reviews_On_Conflict = {
  constraint: Reviews_Constraint;
  update_columns: Array<Reviews_Update_Column>;
};

/** ordering options when selecting data from "reviews" */
export type Reviews_Order_By = {
  business?: Maybe<Businesses_Order_By>;
  bussiness_id?: Maybe<Order_By>;
  id?: Maybe<Order_By>;
  rating?: Maybe<Order_By>;
  text?: Maybe<Order_By>;
};

/** select columns of table "reviews" */
export enum Reviews_Select_Column {
  /** column name */
  BussinessId = "bussiness_id",
  /** column name */
  Id = "id",
  /** column name */
  Rating = "rating",
  /** column name */
  Text = "text"
}

/** input type for updating data in table "reviews" */
export type Reviews_Set_Input = {
  bussiness_id?: Maybe<Scalars["uuid"]>;
  id?: Maybe<Scalars["uuid"]>;
  rating?: Maybe<Scalars["Int"]>;
  text?: Maybe<Scalars["String"]>;
};

/** aggregate stddev on columns */
export type Reviews_Stddev_Fields = {
  __typename?: "reviews_stddev_fields";
  rating?: Maybe<Scalars["Float"]>;
};

/** order by stddev() on columns of table "reviews" */
export type Reviews_Stddev_Order_By = {
  rating?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Reviews_Stddev_Pop_Fields = {
  __typename?: "reviews_stddev_pop_fields";
  rating?: Maybe<Scalars["Float"]>;
};

/** order by stddev_pop() on columns of table "reviews" */
export type Reviews_Stddev_Pop_Order_By = {
  rating?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Reviews_Stddev_Samp_Fields = {
  __typename?: "reviews_stddev_samp_fields";
  rating?: Maybe<Scalars["Float"]>;
};

/** order by stddev_samp() on columns of table "reviews" */
export type Reviews_Stddev_Samp_Order_By = {
  rating?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Reviews_Sum_Fields = {
  __typename?: "reviews_sum_fields";
  rating?: Maybe<Scalars["Int"]>;
};

/** order by sum() on columns of table "reviews" */
export type Reviews_Sum_Order_By = {
  rating?: Maybe<Order_By>;
};

/** update columns of table "reviews" */
export enum Reviews_Update_Column {
  /** column name */
  BussinessId = "bussiness_id",
  /** column name */
  Id = "id",
  /** column name */
  Rating = "rating",
  /** column name */
  Text = "text"
}

/** aggregate var_pop on columns */
export type Reviews_Var_Pop_Fields = {
  __typename?: "reviews_var_pop_fields";
  rating?: Maybe<Scalars["Float"]>;
};

/** order by var_pop() on columns of table "reviews" */
export type Reviews_Var_Pop_Order_By = {
  rating?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Reviews_Var_Samp_Fields = {
  __typename?: "reviews_var_samp_fields";
  rating?: Maybe<Scalars["Float"]>;
};

/** order by var_samp() on columns of table "reviews" */
export type Reviews_Var_Samp_Order_By = {
  rating?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Reviews_Variance_Fields = {
  __typename?: "reviews_variance_fields";
  rating?: Maybe<Scalars["Float"]>;
};

/** order by variance() on columns of table "reviews" */
export type Reviews_Variance_Order_By = {
  rating?: Maybe<Order_By>;
};

/** subscription root */
export type Subscription_Root = {
  __typename?: "subscription_root";
  /** fetch data from the table: "businesses" */
  businesses: Array<Businesses>;
  /** fetch aggregated fields from the table: "businesses" */
  businesses_aggregate: Businesses_Aggregate;
  /** fetch data from the table: "businesses" using primary key columns */
  businesses_by_pk?: Maybe<Businesses>;
  /** fetch data from the table: "reviews" */
  reviews: Array<Reviews>;
  /** fetch aggregated fields from the table: "reviews" */
  reviews_aggregate: Reviews_Aggregate;
  /** fetch data from the table: "reviews" using primary key columns */
  reviews_by_pk?: Maybe<Reviews>;
};

/** subscription root */
export type Subscription_RootBusinessesArgs = {
  distinct_on?: Maybe<Array<Businesses_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Businesses_Order_By>>;
  where?: Maybe<Businesses_Bool_Exp>;
};

/** subscription root */
export type Subscription_RootBusinesses_AggregateArgs = {
  distinct_on?: Maybe<Array<Businesses_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Businesses_Order_By>>;
  where?: Maybe<Businesses_Bool_Exp>;
};

/** subscription root */
export type Subscription_RootBusinesses_By_PkArgs = {
  id: Scalars["uuid"];
};

/** subscription root */
export type Subscription_RootReviewsArgs = {
  distinct_on?: Maybe<Array<Reviews_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Reviews_Order_By>>;
  where?: Maybe<Reviews_Bool_Exp>;
};

/** subscription root */
export type Subscription_RootReviews_AggregateArgs = {
  distinct_on?: Maybe<Array<Reviews_Select_Column>>;
  limit?: Maybe<Scalars["Int"]>;
  offset?: Maybe<Scalars["Int"]>;
  order_by?: Maybe<Array<Reviews_Order_By>>;
  where?: Maybe<Reviews_Bool_Exp>;
};

/** subscription root */
export type Subscription_RootReviews_By_PkArgs = {
  id: Scalars["uuid"];
};

/** expression to compare columns of type text. All fields are combined with logical 'AND'. */
export type Text_Comparison_Exp = {
  _eq?: Maybe<Scalars["String"]>;
  _gt?: Maybe<Scalars["String"]>;
  _gte?: Maybe<Scalars["String"]>;
  _ilike?: Maybe<Scalars["String"]>;
  _in?: Maybe<Array<Scalars["String"]>>;
  _is_null?: Maybe<Scalars["Boolean"]>;
  _like?: Maybe<Scalars["String"]>;
  _lt?: Maybe<Scalars["String"]>;
  _lte?: Maybe<Scalars["String"]>;
  _neq?: Maybe<Scalars["String"]>;
  _nilike?: Maybe<Scalars["String"]>;
  _nin?: Maybe<Array<Scalars["String"]>>;
  _nlike?: Maybe<Scalars["String"]>;
  _nsimilar?: Maybe<Scalars["String"]>;
  _similar?: Maybe<Scalars["String"]>;
};

/** expression to compare columns of type uuid. All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: Maybe<Scalars["uuid"]>;
  _gt?: Maybe<Scalars["uuid"]>;
  _gte?: Maybe<Scalars["uuid"]>;
  _in?: Maybe<Array<Scalars["uuid"]>>;
  _is_null?: Maybe<Scalars["Boolean"]>;
  _lt?: Maybe<Scalars["uuid"]>;
  _lte?: Maybe<Scalars["uuid"]>;
  _neq?: Maybe<Scalars["uuid"]>;
  _nin?: Maybe<Array<Scalars["uuid"]>>;
};
export type BusinessListQueryQueryVariables = {};

export type BusinessListQueryQuery = { __typename?: "query_root" } & {
  businesses: Array<
    { __typename?: "businesses" } & Pick<Businesses, "id" | "name"> & {
        reviews: Array<
          { __typename?: "reviews" } & Pick<Reviews, "id" | "rating" | "text">
        >;
      }
  >;
};

export const BusinessListQueryDocument = gql`
  query businessListQuery {
    businesses(limit: 10) {
      id
      name
      reviews {
        id
        rating
        text
      }
    }
  }
`;
export type BusinessListQueryComponentProps = Omit<
  ReactApollo.QueryProps<
    BusinessListQueryQuery,
    BusinessListQueryQueryVariables
  >,
  "query"
>;

export const BusinessListQueryComponent = (
  props: BusinessListQueryComponentProps
) => (
  <ReactApollo.Query<BusinessListQueryQuery, BusinessListQueryQueryVariables>
    query={BusinessListQueryDocument}
    {...props}
  />
);

export type BusinessListQueryProps<TChildProps = {}> = Partial<
  ReactApollo.DataProps<BusinessListQueryQuery, BusinessListQueryQueryVariables>
> &
  TChildProps;
export function withBusinessListQuery<TProps, TChildProps = {}>(
  operationOptions?: ReactApollo.OperationOption<
    TProps,
    BusinessListQueryQuery,
    BusinessListQueryQueryVariables,
    BusinessListQueryProps<TChildProps>
  >
) {
  return ReactApollo.withQuery<
    TProps,
    BusinessListQueryQuery,
    BusinessListQueryQueryVariables,
    BusinessListQueryProps<TChildProps>
  >(BusinessListQueryDocument, {
    alias: "withBusinessListQuery",
    ...operationOptions
  });
}
